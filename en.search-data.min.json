[{"id":0,"href":"/plugin_tutorial/getting_started/","title":"Setup your installs","parent":"Plugin Tutorial","content":"Trying to get into making plugins for the first time? There\u0026rsquo;s some super useful tools out there! These steps should get you started on the path towards development.\nNote these instructions are designed for Windows 10 (and presumably 11). Rocket League is Windows exclusive, so this is the easiest way to develop for it. If you really want to use linux, it will be harder but may still be possible\n Make sure you have bakkesmod installed and run it at least once https://bakkesmod.com/\u0026nbsp; Download Visual Studio (any version should work although most devs use VS19). Note that this is not the same as Visual Studio Code https://visualstudio.microsoft.com/\u0026nbsp; During Visual Studio\u0026rsquo;s install, make sure you select and download the C++ and Windows 10 SDK options Download the plugin template as instructed in it\u0026rsquo;s README. This makes things much easier to work with and automatically handles include paths for your plugin. Martinn is a wizard https://github.com/Martinii89/BakkesmodPluginTemplate\u0026nbsp; Open Visual Studio and create a new project. You should see BakkesModPlugin as a template type. Start coding! When you build, your plugin will automatically be moved into your plugins folder, and it will load in Rocket League. If you\u0026rsquo;re having trouble understanding how to start the code, try looking at Starting A Plugin and the code snippets for some examples on how Bakkesmod SDK is used  "},{"id":1,"href":"/functions/using_function_hooks/","title":"Using Function Hooks","parent":"Functions","content":"Function hooks are a powerful part of BakkesMod. After a function is hooked, any time it is called by Rocket League, your code is called as well.\nThere are multiple types of hooks. First are the two simpler ones. gameWrapper is a GameWrapper and will be accessible from any point in your code.\ngameWrapper-\u0026gt;HookEvent(\u0026#34;Function TAGame.Car_TA.SetVehicleInput\u0026#34;, [this](std::string eventName) { // Your Code here  // Call another function or just do your things here }); gameWrapper-\u0026gt;HookEventPost(\u0026#34;Function TAGame.Car_TA.SetVehicleInput\u0026#34;, [this](std::string eventName) { // Your Code here }); HookEvent runs your code as the function is called HookEventPost runs your code as the function is returned from They return a std::string which is the name of the calling function. This is useful to differentiate what your caller is if you have multiple hooks calling the same code.\ngameWrapper-\u0026gt;HookEventWithCaller\u0026lt;CarWrapper\u0026gt;(\u0026#34;Function TAGame.Car_TA.SetVehicleInput\u0026#34;, [this](CarWrapper caller, void* params, std::string eventname) { // Your Code here }); gameWrapper-\u0026gt;HookEventWithCallerPost\u0026lt;CarWrapper\u0026gt;(\u0026#34;Function TAGame.Car_TA.SetVehicleInput\u0026#34;, [this](CarWrapper caller, void* params, std::string eventname) { // Your Code here }); The two WithCaller variants do the same thing, but let you know a bit more about what is using the function\nThey provide a caller value which is obtained from the function\u0026rsquo;s name. After Function TAGame there will be a class name ending in _TA. If the name matches a wrapper name, you can hook it as that wrapper. Car_TA becomes CarWrapper for example They also provide a void * pointer. This points at the location of any parameters provided to the function. These aren\u0026rsquo;t well documented, and are hard to guess, so feel free to ask about them if you think you need them\nFind functions with the function scanner\n"},{"id":2,"href":"/functions/function_scanner/","title":"Function Scanner","parent":"Functions","content":"Trying to hook an event but don\u0026rsquo;t know what event to use? There\u0026rsquo;s way more events out there than can be documented, so you can find one yourself with the function scanner\nI highly recommend this video I made to understand how to use it, but there\u0026rsquo;s also a text guide below https://www.youtube.com/watch?v=gDZ1wWKE8aw\u0026nbsp;\nSet the -dev option    On Steam: Right click the game and hit properties Then add the option On Epic: (They\u0026rsquo;ve moved this before so @ me if it\u0026rsquo;s in a new place)\nHit Settings Scroll down to Rocket League, enable Additional Command Line arguments, then add -dev Reboot and open scanner    Now that you\u0026rsquo;ve enabled -dev, reboot rocket league with bakkesmod open Once injected, open the console with f6 and type togglemenu devtools The scanner will now open Use the scanner    You can select any words you think are relevant and add them to the whitelist. Any words that aren\u0026rsquo;t relevant can be added to the blacklist. Separate words with , but no space a, b will match a and [space]b. When you hit apply, any functions containing words matching the whitelist and not matching the blacklist will appear. These will appear as they happen, so it\u0026rsquo;s a good way to find out when functions fire, and what timing you want. This video\u0026nbsp; does a much better job of explaining this part\nHook the Function    When you\u0026rsquo;ve found the right function, hook it using gameWrapper-\u0026gt;HookEvent(). Details here\nEvery time that function happens, your code will be run. This can be used to know when something important happens (a goal), get pointers to hard-to-find wrappers, or just be used to help you do something on a consistent timer.\nHooks are the hardest part of Bakkesmod programming, but can have the most interesting results\n"},{"id":3,"href":"/plugin_tutorial/starting_a_plugin/","title":"Starting a plugin","parent":"Plugin Tutorial","content":"It will assume you\u0026rsquo;re using the template as linked in Setting Up. You can of course make a plugin without it, but it gives an easier basis to work off of. You can name it anything, but here we\u0026rsquo;ll be using a demo plugin named CoolPlugin\nThe template has a lot of commented out code that is designed to help you learn how to use the syntax, but is ignored for the purposes of this tutorial\nFirst we\u0026rsquo;ll look at your CoolPlugin.h file. It describes any functions your code will use At the top are two lines that are required for plugins, and allow you to call BakkesMod SDK functions\n#pragma once #include \u0026#34;bakkesmod/plugin/bakkesmodplugin.h\u0026#34;Next is the declaration of your class. Here you describe any functions you will be using. onLoad() is automatically called by BakkesMod when the plugin is loaded, and onUnload() is called when it is unloaded\nclass CoolPlugin: public BakkesMod::Plugin::BakkesModPlugin { virtual void onLoad(); virtual void onUnload(); }; Now we will look at the CoolPlugin.cpp file. Here you write the code that will define the functions First it includes your header so it can define the functions described above\n#include \u0026#34;pch.h\u0026#34;#include \u0026#34;CoolPlugin.h\u0026#34;Next it declares the plugin. The string in \u0026quot;\u0026quot; will be used in the plugin manager to describe the plugin, but it needs to be a short description. Keep it to 1 or two words. You can also define a plugin version, although the template handles that automatically. Finally is the plugin type described here. If you don\u0026rsquo;t know what it is, just use PLUGINTYPE_FREEPLAY.\nBAKKESMOD_PLUGIN(CoolPlugin, \u0026#34;Cool Plugin\u0026#34;, plugin_version, PLUGINTYPE_FREEPLAY) Next you define your functions, starting with onLoad(). As this is a demo, we\u0026rsquo;ll just do a hello world.\nvoid CoolPlugin::onLoad() { // do something when it loads  cvarManager-\u0026gt;log(\u0026#34;Hello I\u0026#39;m CoolPlugin B)\u0026#34;); } Next is onUnload(). Bakkesmod handles most of unloading, so only worry about this if your code is using some 3rd party library that needs unloading to be handled specially. For now this can just log that it unloaded\nvoid CoolPlugin::onUnload() { cvarManager-\u0026gt;log(\u0026#34;I was too cool for this world B\u0026#39;(\u0026#34;); } Now you\u0026rsquo;ve got a super basic plugin. Hit Build -\u0026gt; Build CoolPlugin or press ctrl + B to finalize the plugin. It will create CoolPlugin.dll in a plugins/ folder next to your plugin source code. It will also move it into your bakkesmod folder if you are using the template.\nNow open Rocket League and open the BakkesMod console with f6. Type plugin load CoolPlugin and you should see it load and say hello! If you unload it with plugin unload CoolPlugin you should see it say goodbye to you :cry:\nNext we\u0026rsquo;ll make the plugin actually do something. We\u0026rsquo;ll reverse engineer the ballontop command, which puts the ball on top of your car in freeplay. In CoolPlugin.h add a new function\nclass CoolPlugin: public BakkesMod::Plugin::BakkesModPlugin { virtual void onLoad(); virtual void onUnload(); void ballOnTop(); }; We need to define that function in CoolPlugin.cpp. Just jump to the end of the file and add\nvoid CoolPlugin::ballOnTop() { } â € The next lines of code are all going to be within CoolPlugin::ballOnTop() in CoolPlugin.cpp\nFirst we need to make sure we should be running the plugin. We only want it to work in freeplay. The gameWrapper gives a ton of useful functions to figure out what context the code is being run from. The first line of CoolPlugin::ballOnTop() will be\nif (!gameWrapper-\u0026gt;IsInFreeplay()) { return; } There are also gameWrapper-\u0026gt;IsInGame() and gameWrapper-\u0026gt;IsInOnlineGame() if you\u0026rsquo;d rather your plugin run elsewhere\nThe next line will be getting the ServerWrapper. This is what controls pretty much everything in the current game. You can get players, cars, the ball, the goals, and other things from it so it\u0026rsquo;s incredibly useful. We also nullcheck it. If you call functions on a null server Rocket League will crash\nServerWrapper server = gameWrapper-\u0026gt;GetCurrentGameState(); if (!server) { return; } Next we get the ball and nullcheck it\nBallWrapper ball = server.GetBall(); if (!ball) { return; } And we get the car. As this is freeplay we only have one to worry about, but in any mode this will select your car. And we nullcheck it. If this seems redundant, it isn\u0026rsquo;t\nCarWrapper car = gameWrapper-\u0026gt;GetLocalCar(); if (!car) { return; } Next we can start manipulating things. We can grab the car\u0026rsquo;s velocity and assign it to the ball so they match. If the ball is going slower or faster than the car, it\u0026rsquo;ll just fly off by itself\nVector carVelocity = car.GetVelocity(); ball.SetVelocity(carVelocity); Next we\u0026rsquo;ll actually move the ball. A Vector is a 3 dimensional point in space. The Z axis is up and down in Rocket League, so we can put the ball above the car by using the car\u0026rsquo;s location and adding distance on the Z axis.\nVector carLocation = car.GetLocation(); float ballRadius = ball.GetRadius(); ball.SetLocation(carLocation + Vector{0, 0, ballRadius * 2}); We\u0026rsquo;ve now defined CoolPlugin::ballOnTop() In full:\nvoid CoolPlugin::ballOnTop() { if (!gameWrapper-\u0026gt;IsInFreeplay()) { return; } ServerWrapper server = gameWrapper-\u0026gt;GetCurrentGameState(); if (!server) { return; } BallWrapper ball = server.GetBall(); if (!ball) { return; } CarWrapper car = gameWrapper-\u0026gt;GetLocalCar(); if (!car) { return; } Vector carVelocity = car.GetVelocity(); ball.SetVelocity(carVelocity); Vector carLocation = car.GetLocation(); float ballRadius = ball.GetRadius(); ball.SetLocation(carLocation + Vector{0, 0, ballRadius * 2}); } Now we need to call the function\nThis can be done with a notifier. These can be called with a console command to activate your code. Here we\u0026rsquo;ll define it as CoolerBallOnTop because Bakkes' ballontop is for the birds. When it\u0026rsquo;s called, it takes a vector (basically a list) of command arguments that were provided by the command. Here we don\u0026rsquo;t care about those, so they are unused. The code is called in a lambda [](){}. You can just copy the syntax here. Next is the notifier description, which does nothing, so it\u0026rsquo;ll be \u0026quot;\u0026quot;. Finally is the permissions, which should usually be PERMISSION_ALL. If you want to restrict it you can use the list LINKED HERE\ncvarManager-\u0026gt;registerNotifier(\u0026#34;CoolerBallOnTop\u0026#34;, [this](std::vector\u0026lt;std::string\u0026gt; args) { ballOnTop(); }, \u0026#34;\u0026#34;, PERMISSION_ALL); Now we\u0026rsquo;ll put it all together.\n// CoolPlugin.h #pragma once  #include \u0026#34;bakkesmod/plugin/bakkesmodplugin.h\u0026#34;#include \u0026#34;bakkesmod/plugin/pluginwindow.h\u0026#34; class CoolPlugin : public BakkesMod::Plugin::BakkesModPlugin { virtual void onLoad(); virtual void onUnload(); void ballOnTop(); }; // CoolPlugin.cpp #include \u0026#34;pch.h\u0026#34;#include \u0026#34;CoolPlugin.h\u0026#34; BAKKESMOD_PLUGIN(CoolPlugin, \u0026#34;Cool Plugin\u0026#34;, plugin_version, PLUGINTYPE_FREEPLAY) void CoolPlugin::onLoad() { cvarManager-\u0026gt;log(\u0026#34;Hello I\u0026#39;m CoolPlugin B)\u0026#34;); cvarManager-\u0026gt;registerNotifier(\u0026#34;CoolerBallOnTop\u0026#34;, [this](std::vector\u0026lt;std::string\u0026gt; args) { ballOnTop(); }, \u0026#34;\u0026#34;, PERMISSION_ALL); } void CoolPlugin::onUnload() { cvarManager-\u0026gt;log(\u0026#34;I was too cool for this world B\u0026#39;(\u0026#34;); } void CoolPlugin::ballOnTop() { if (!gameWrapper-\u0026gt;IsInFreeplay()) { return; } ServerWrapper server = gameWrapper-\u0026gt;GetCurrentGameState(); if (!server) { return; } BallWrapper ball = server.GetBall(); if (!ball) { return; } CarWrapper car = gameWrapper-\u0026gt;GetLocalCar(); if (!car) { return; } Vector carVelocity = car.GetVelocity(); ball.SetVelocity(carVelocity); Vector carLocation = car.GetLocation(); float ballRadius = ball.GetRadius(); ball.SetLocation(carLocation + Vector{ 0, 0, ballRadius * 2 }); } Finally build the plugin with ctrl + b. Then start freeplay, load the plugin with plugin load CoolPlugin and call CoolerBallOnTop from the f6 console. The ball should teleport above you!\nYou can find the final code here! https://github.com/ubelhj/BakkesModStarterPlugin/tree/starter-tutorial\u0026nbsp;\nNow what if you wanted a user to be able to modify plugin behavior on the fly? Next are Plugin Variables\n"},{"id":4,"href":"/functions/commonly_hooked_functions/","title":"Commonly Hooked Functions","parent":"Functions","content":"This is a list of functions that we use regularly, as well as when they fire. We\u0026rsquo;ll never be able to document them all but hopefully this helps. Hook them with Function Hooks\n\u0026quot;Function TAGame.Car_TA.SetVehicleInput\u0026quot; This event is called every physics tick while you are playing. This is 120 times per second. This can be highly useful but isn\u0026rsquo;t perfect. It doesn\u0026rsquo;t fire while spectating matches. While hosting a match it fires once per tick per car in the match. The caller is a CarWrapper\n\u0026quot;Function Engine.GameViewportClient.Tick\u0026quot; This event is called every rendered frame. This is very powerful, but again can have issues. Different framerates and stutters can make the number of ticks different on different PCs\n\u0026quot;Function TAGame.Ball_TA.OnCarTouch\u0026quot; This event is called when a BallWrapper hits a car. The caller is the ball that hit, and the first parameter is the CarWrapper touched\n\u0026quot;Function TAGame.Car_TA.OnHitBall\u0026quot; This event is called when a car hits a ball. The caller is the CarWrapper that hit, and the first parameter is the BallWrapper touched\n\u0026quot;Function TAGame.GameEvent_Soccar_TA.EventMatchEnded\u0026quot; Happens at the end of a match when the podium is shown. If someone quits early it is not called\n\u0026quot;Function TAGame.GFxData_MainMenu_TA.MainMenuAdded\u0026quot; Happens when the main menu is opened, either through booting the game or leaving a mode\n"},{"id":5,"href":"/plugin_tutorial/plugin_variables/","title":"Plugin Variables","parent":"Plugin Tutorial","content":"Next we will make your plugin alterable by a user. They might want to enable/disable the plugin, change how it acts, and pretty much infinite options. I\u0026rsquo;ll be using a fairly simple plugin I\u0026rsquo;ve made as an example. I\u0026rsquo;ll only be focusing on the settings, not the actual code that makes it work. We\u0026rsquo;ll continue the CoolPlugin from Starting a Plugin\nWe give the users control with the Console Variables, CVars. They allow a user to set a named variable\u0026rsquo;s value, and for our code to know when those values are changed. These can be used to store string, int, bool, float, or color values\nTo create one, we call cvarManager-\u0026gt;registerCvar() There are 2-9 arguments. The first 2 are required, but the others are not\n The name. This should include your plugin name and make sense The default value as a string. If it\u0026rsquo;s a boolean, remember 0 is false and 1 is true A description of the CVar as a string. The name can describe your variable well, so this isn\u0026rsquo;t super necessary Whether your CVar is searchable. If someone starts typing the name of your CVar, and this is true it suggests the CVar. Defaults to true Whether your CVar has a minimum value. Defaults to false The minimum value of your CVar if it exists. If the previous is false this value can be anything and is ignored Whether your CVar has a maximum value. Defaults to false The maximum value of your CVar if it exists. If the previous is false this value can be anything and is ignored Whether the CVar\u0026rsquo;s value is stored between sessions. Defaults to true  To create an enable/disable CVar for the plugin and a ball distance CVar\ncvarManager-\u0026gt;registerCvar(\u0026#34;cool_enabled\u0026#34;, \u0026#34;0\u0026#34;, \u0026#34;Enable Cool\u0026#34;, true, true, 0, true, 1); cvarManager-\u0026gt;registerCvar(\u0026#34;cool_distance\u0026#34;, \u0026#34;200.0\u0026#34;, \u0026#34;Distance to place the ball above\u0026#34;); A user can use these by typing into the f6 console cool_enabled 1 to enable cool, or cool_distance 300 to move the ball away\nNow we\u0026rsquo;ve got the CVar. But what do we do with it? There\u0026rsquo;s two good ways to use it. Either we can do something when the value is changed, or we can get the value from the CVar as we use the value\nFirst is CVarWrapper.addOnValueChanged() This creates a function that is called when the value is changed. Quite simple. The string simply is what the old value was. The CVarWrapper holds the new value. The [](){} is called a lambda, and is basically just a helper function. We put [this] so we can access our global variables inside the lambda. (std::string oldValue, CVarWrapper cvar) are the values passed to the lambda by the addOnValueChanged function. Every time the value changes and the lambda is called, the code inside {} happens. The most common use is to change the value of a global variable. If I had a variable bool coolEnabled, I could call coolEnabled = cvar.getBoolValue(); inside the brackets to change its value\ncvarManager-\u0026gt;registerCvar(\u0026#34;cool_enabled\u0026#34;, \u0026#34;0\u0026#34;, \u0026#34;Enable Cool\u0026#34;, true, true, 0, true, 1) .addOnValueChanged([this](std::string oldValue, CVarWrapper cvar) { coolEnabled = cvar.getBoolValue(); }); The second is by getting the CVar and then its value in another function. We can call cvarManager-\u0026gt;getCvar() with the name of any CVar to get and/or set the value of that CVar, even ones that aren\u0026rsquo;t from our plugin.\nCVarWrapper distanceCVar = cvarManager-\u0026gt;getCvar(\u0026#34;cool_distance\u0026#34;); if (!distanceCVar) { return; } float distance = distanceCVar.getFloatValue(); We can put together this knowledge to add to CoolPlugin.cpp https://github.com/ubelhj/BakkesModStarterPlugin/blob/plugin-settings/CoolPlugin/CoolPlugin.cpp\u0026nbsp;\nThis isn\u0026rsquo;t enough though. Who want to be changing an integer value with a console command? Gross. What if we had sliders? Checkboxes? Buttons? Plugin Interface\n"},{"id":6,"href":"/functions/hook_event_with_any_caller/","title":"Hook Event With Any Caller","parent":"Functions","content":"Add this to your plugin header and you can hook with caller for \u0026ldquo;anything\u0026rdquo;. This will do a blind cast, so make absolutely sure you\u0026rsquo;re hooking the right function or you will crash. There are no type checks here!\ntemplate \u0026lt;typename T, typename std::enable_if\u0026lt;std::is_base_of\u0026lt;ObjectWrapper, T\u0026gt;::value\u0026gt;::type*\u0026gt; void GameWrapper::HookEventWithCaller(std::string eventName, std::function\u0026lt;void(T caller, void* params, std::string eventName)\u0026gt; callback) { auto wrapped_callback = [callback](ActorWrapper caller, void* params, std::string eventName) { callback(T(caller.memory_address), params, eventName); }; HookEventWithCaller\u0026lt;ActorWrapper\u0026gt;(eventName, wrapped_callback); } And this for Post\ntemplate \u0026lt;typename T, typename std::enable_if\u0026lt;std::is_base_of\u0026lt;ObjectWrapper, T\u0026gt;::value\u0026gt;::type*\u0026gt; void GameWrapper::HookEventWithCallerPost(std::string eventName, std::function\u0026lt;void(T caller, void* params, std::string eventName)\u0026gt; callback) { auto wrapped_callback = [callback](ActorWrapper caller, void* params, std::string eventName) { callback(T(caller.memory_address), params, eventName); }; HookEventWithCallerPost\u0026lt;ActorWrapper\u0026gt;(eventName, wrapped_callback); } "},{"id":7,"href":"/plugin_tutorial/plugin_interface/","title":"Plugin Interface","parent":"Plugin Tutorial","content":"This channel will go over creating a user-friendly interface. There\u0026rsquo;s buttons, sliders, checkboxes, dropdowns, and all sorts of options. It also assumes you\u0026rsquo;re using the template, as the template automatically includes the ImGui GUI library we\u0026rsquo;ll be using. It will ignore the fact that there is some commented out code in CoolPluginGUI.cpp.\nYet again we have the CoolPlugin from Plugin Variables and we want to add a button to activate our cooler ball on top, a checkbox to enable cool, and a slider to choose the distance that the ball is placed from your car\nFirst we need to extend a class and declare 3 functions in CoolPlugin.h\nAt the top of the file, add the line to your list of includes #include \u0026quot;bakkesmod/plugin/PluginSettingsWindow.h\u0026quot;\nAt the class declaration, add PluginSettingsWindow\nclass CoolPlugin: public BakkesMod::Plugin::BakkesModPlugin, public BakkesMod::Plugin::PluginSettingsWindow And inside the plugin {} add these 3 lines\nvoid RenderSettings() override; std::string GetPluginName() override; void SetImGuiContext(uintptr_t ctx) override; Now we can define those 3 functions to create the interface. We will put these in CoolPluginGUI.cpp but they can be in any .cpp file that includes CoolPlugin.h, such as CoolPlugin.cpp\nThe first is simple and should be copied and pasted. Never call this function, just assume it works\nvoid CoolPlugin::SetImGuiContext(uintptr_t ctx) { ImGui::SetCurrentContext(reinterpret_cast\u0026lt;ImGuiContext*\u0026gt;(ctx)); } The second is also simple. Put whatever the name of the plugin is as the return value. This\u0026rsquo;ll be what the plugin will be called in the f2 -\u0026gt; Plugins menu\nstd::string CoolPlugin::GetPluginName() { return \u0026#34;Cool Plugin\u0026#34;; } The third and final actually creates the interface. We\u0026rsquo;ll start with simple text but this is what we\u0026rsquo;ll be modifying in the rest of this channel There\u0026rsquo;s a hugely important thing to consider with this function. Never call on or change any Rocket League / Bakkesmod values here. If you do, you will crash. It\u0026rsquo;s happening outside of the game, and cannot safely alter it. That means that if you have a CVarWrapper.addOnValueChanged() that alters the state of the game, it will be unsafe to use here\nvoid CoolPlugin::RenderSettings() { ImGui::TextUnformatted(\u0026#34;A really cool plugin\u0026#34;); } Lets start building the plugin interface. First we\u0026rsquo;ll have a button that\u0026rsquo;ll call CoolerBallOnTop. The button as well as most other interactable ImGui components has a boolean property. If it\u0026rsquo;s true, that means it\u0026rsquo;s been interacted with. So when the button has been clicked, we\u0026rsquo;ll use the cvarManager to call CoolerBallOnTop. But CoolerBallOnTop uses the ServerWrapper and alters the game. It\u0026rsquo;ll crash! We can wrap it inside gameWrapper-\u0026gt;Execute(). We\u0026rsquo;ll also add hover text because why not\nif (ImGui::Button(\u0026#34;Ball On Top\u0026#34;)) { gameWrapper-\u0026gt;Execute([this](GameWrapper* gw) { cvarManager-\u0026gt;executeCommand(\u0026#34;CoolerBallOnTop\u0026#34;); }); } if (ImGui::IsItemHovered()) { ImGui::SetTooltip(\u0026#34;Activate Ball On Top\u0026#34;); } Now let\u0026rsquo;s do a checkbox for cool_enabled. First we need to get the CVar, then use it. The bool enabled is necessary, as the checkbox uses that to store whether or not the checkbox should be checked. You can\u0026rsquo;t just use the CVar\nCVarWrapper enableCvar = cvarManager-\u0026gt;getCvar(\u0026#34;cool_enabled\u0026#34;); if (!enableCvar) { return; } bool enabled = enableCvar.getBoolValue(); if (ImGui::Checkbox(\u0026#34;Enable plugin\u0026#34;, \u0026amp;enabled)) { enableCvar.setValue(enabled); } if (ImGui::IsItemHovered()) { ImGui::SetTooltip(\u0026#34;Toggle Cool Plugin\u0026#34;); } And finally a slider for the distance CVar. ImGui elements use char * instead of std::string You can easily convert between with std::string.c_str() and std::string newStringVariableName(char *)\nCVarWrapper distanceCvar = cvarManager-\u0026gt;getCvar(\u0026#34;cool_distance\u0026#34;); if (!distanceCvar) { return; } float distance = distanceCvar.getFloatValue(); if (ImGui::SliderFloat(\u0026#34;Distance\u0026#34;, \u0026amp;distance, 0.0, 500.0)) { distanceCvar.setValue(distance); } if (ImGui::IsItemHovered()) { std::string hoverText = \u0026#34;distance is \u0026#34; + std::to_string(distance); ImGui::SetTooltip(hoverText.c_str()); } We finally have a settings file using all of our CVars. There\u0026rsquo;s a load more things you can do with ImGui, but hopefully this is enough to get the right idea and get started. I hope that by covering these three elements I covered most of what plugins need to use. ImGui is complicated and most plugins don\u0026rsquo;t use it yet. Feel free to ask questions\nHere\u0026rsquo;s the final code https://github.com/ubelhj/BakkesModStarterPlugin/blob/plugin-settings/CoolPlugin/CoolPlugin.h\u0026nbsp; https://github.com/ubelhj/BakkesModStarterPlugin/blob/plugin-settings/CoolPlugin/CoolPluginGUI.cpp\u0026nbsp;\nAnd here\u0026rsquo;s a useful interactable imgui demo https://pthom.github.io/imgui_manual_online/manual/imgui_manual.html\u0026nbsp;\n"},{"id":8,"href":"/bakkesmod_api/","title":"BakkesMod API","parent":"Welcome to the BakkesMod Programming Wiki!","content":"About    BakkesMod provides a powerful SDK, accessible in c++. Visit the Plugin Tutorial sections to get started!\nLinks     C++ Reference\u0026nbsp;  "},{"id":9,"href":"/categories/","title":"Categories","parent":"Welcome to the BakkesMod Programming Wiki!","content":""},{"id":10,"href":"/code_snippets/code_snippet_example/","title":"Code Snippet Example","parent":"Code Snippets","content":"If you want to add a new snippet to the page, simply make a code snippet in this folder like this\nGive your snippet a unique name and send the pull request!\nThe filename will be the name of the page, with _ replaced with spaces and automatic proper capitalization\nEverything is written in Markdown\nMake code blocks using Markdown\n```cpp\n// code here\n```\nbecomes\n// code here "},{"id":11,"href":"/useful_info/crash_dumps/","title":"Crash Dumps","parent":"Useful Info","content":"Modding RL is finnicky. You\u0026rsquo;re going to crash the game at some point. This will tell you how to learn from a crash and solve your issue.\nCrashes are often logged in .dmp files. They are found at My Documents/My Games/rocketleague/TAGame/Logs\nUnfortunately sometimes there is no .dmp file. That often means you crashed in a non-game thread, like rendering or websockets. For those you might just need to do some logging to find out where you crashed\nMake sure you have the exact version of the source code that crashed the game and the .pdb of that exact build loaded in a visual studio project. For this I highly recommend using git. Even for private projects, this can save you when you have to look back at old versions of code. Make a commit for the source code that you\u0026rsquo;ve uploaded to bakkesplugins.\nDrag the .dmp over the visual studio window\nYou\u0026rsquo;ll get a Minidump File Summary, which explains in super basic terms what the issue was. It won\u0026rsquo;t be specific though, so hit the green \u0026ldquo;Debug with Native Only\u0026rdquo; button\nNext it will try to load symbols. If this is taking more than a couple seconds, it\u0026rsquo;s loading too many symbols. Cancel the loading and go to Debug -\u0026gt; Options -\u0026gt; Symbols\nMake sure that Microsoft Symbol Servers is the only symbol location selected and that Load only specified modules is selected\nThen try to debug with native again. Be aware that these settings mysteriously can reset themselves (they did so in the time it took me to write this up) so you might have to refer back here fairly often.\nIf Visual Studio can find the issue, it will then tell you the issue and automatically jump to it. I dereferenced a null pointer! Oops\nSometimes it\u0026rsquo;s a little less easy, and the issue happens in pluginsdk.dll or RocketLeague.exe. In this case Visual Studio will try its best to find it but may fail\nThis crash happened because of a null ball! Remember that whenever you use any type that ends with Wrapper like this BallWrapper you must nullcheck it before using it. These 4 lines of code will save your plugin from crashing\nBallWrapper* ball = (BallWrapper*) nullptr; if (!ball) { cvarManager-\u0026gt;log(\u0026#34;null ball\u0026#34;); // I am saved from crashing!  return; } // guaranteed to only happen on valid balls and not crash ball-\u0026gt;SetLocation(Vector(0, 0, 0)); Once you\u0026rsquo;ve found the issue, hit the red square up top\nHopefully you\u0026rsquo;ve found your issue. If not, try adding many cvarManager-\u0026gt;log(\u0026quot;\u0026quot;); in places where you\u0026rsquo;re suspicious a crash may have happened. If a log doesn\u0026rsquo;t happen that you expected to, you likely crashed before that statement. Debugging can be tedious, but hopefully the .dmp files can help\n"},{"id":12,"href":"/code_snippets/creating_image_wrapper/","title":"Creating an ImageWrapper","parent":"Code Snippets","content":"Creating an ImageWrapper     You should use some kind of reference type that manages the memory. std::shared_ptr\u0026lt;ImageWrapper\u0026gt; is my recommendation. The constructor takes 3 arguments (2 are optional) The optional arguments are two bools that decide if the core will preload the images for use in the canvas\\imgui. The ImageWrapper is a resource managing class. This means that you have to keep this object \u0026ldquo;alive\u0026rdquo; as long as you want to use the image. When the object goes out of scope \\ gets destructed it cleans up the resource it manages. I have tried to delete the constructors that could cause issues (copy constructor). Stick to std::shared_ptr and you almost can\u0026rsquo;t mess up.  Using a ImageWrapper      Use the constructor with the second or third argument true (or both).\n// ImageWrapper(std::string path, bool canvasLoad = false, bool ImGuiLoad = false); myImage = std::make_shared\u0026lt;ImageWrapper\u0026gt;(gameWrapper-\u0026gt;GetDataFolder() / \u0026#34;MyPluginFolder\u0026#34; / \u0026#34;MyImage.png\u0026#34;, true, true);   Load the resource if you didn\u0026rsquo;t use the optional args.\nmyImage-\u0026gt;LoadForCanvas();    Pass it to the canvas wrapper in a drawable callback  canvas.DrawTexture(testImage.get(), 1); // there are multiple functions in the canvaswrapper that accept ImageWrapper* Use it in your imgui render code  if (auto pTex = myImage-\u0026gt;GetImguiTex()) { auto rect = myImage-\u0026gt;GetSizeF(); ImGui::Image(pTex, { rect.width, rect.height }); }   PS: The backend will load in the resource whenever you try to use the images if it hasn\u0026rsquo;t already been loaded. So you actually don\u0026rsquo;t have to worry about it, but the loading can cause some lag\\stutters. So it\u0026rsquo;s better to do it during loading the plugin - when such behaviour can be expected.\n"},{"id":13,"href":"/code_snippets/how_cvars_work/","title":"How CVars Work","parent":"Code Snippets","content":"In plugin onLoad(), registerCVar is called and the cvar will have default values\ncvar values are only changed when a config file is executed, or a console command is fired. It doesn\u0026rsquo;t magically \u0026ldquo;remember\u0026rdquo; values from previous runs or anything.\nOn BM startup, it\u0026rsquo;ll execute plugins.cfg first to load all plugins, causing all cvars for these plugins to be created. Then once this is done it will execute config.cfg, which will set the actual saved value.\nIf you want to reload a plugin while BM is running already but keep its values, make sure you use writeconfig before the plugin is unloaded, then unload/load or reload the plugin, now the plugin will have registered it cvars, but with default values. Then execute config.cfg to get your stored values back\nstd::shared_ptr\u0026lt;bool\u0026gt; enabledOverlay = std::make_shared\u0026lt;bool\u0026gt;(false); auto overlayEnableVar = cvarManager-\u0026gt;registerCvar(\u0026#34;counter_enable_ingame\u0026#34;, \u0026#34;0\u0026#34;, \u0026#34;enables in game overlay\u0026#34;); overlayEnableVar.bindTo(enabledOverlay); overlayEnableVar.addOnValueChanged([this](std::string, CVarWrapper cvar) { doSomethingWhenCounterEnabledChanged(); }); also bindTo is pretty much just a wrapper for\nvoid bindTo(CVar cvar, std::shared_ptr\u0026lt;T\u0026gt; abc) { cvar.addOnValueChanged([this](std::string, CVarWrapper cvar) { *abc = cvar.getTValue(); }); } these std::shared_ptrs only work one way though, cvar -\u0026gt; shared_ptrs. if you alter the shared_ptr directly it will NOT update the actual cvar value. To do that:\nauto cvar = cvarManager-\u0026gt;getCvar(\u0026#34;counter_enable_ingame\u0026#34;); if (!cvar) { // CVarWrappers can be null if the cvar doesn\u0026#39;t exit!  return; } auto overlayEnableVar = cvar.setValue(enabledOverlay.get()); "},{"id":14,"href":"/code_snippets/playlist_id/","title":"Known Playlist IDs","parent":"Code Snippets","content":"All (known) playlist IDs - 2020\n1: Duel 2: Doubles 3: Standard 4: Chaos 6: Private Match 7: Season 8: Exhibition 9: Training 10: Duel (Ranked) 11: Doubles (Ranked) 13: Standard (Ranked) 15: Snow Day 16: Rocket Labs 17: Hoops 18: Rumble 19: Workshop 20: Custom Training Editor 21: Custom Training 22: Tournament Match (Custom) 23: Dropshot 24: Local Match 26: External Match (Ranked) 27: Hoops (Ranked) 28: Rumble (Ranked) 29: Dropshot (Ranked) 30: Snow Day (Ranked) 31: Ghost Hunt 32: Beach Ball 33: Spike Rush 34: Tournament Match (Automatic) 35: Rocket Labs 37: Dropshot Rumble 38: Heatseeker 41: Boomer Ball 43: Heatseeker Doubles 44: Winter Breakaway 46: Gridiron 47: Super Cube 48: TacticalRumble Find the ID of the current playlist with\nServerWrapper sw = gameWrapper-\u0026gt;GetOnlineGame(); if (!sw) return; GameSettingPlaylistWrapper playlist = sw.GetPlaylist(); if (!playlist) return; int playlistID = playlist.GetPlaylistId(); "},{"id":15,"href":"/useful_info/multiplayer_plugins/","title":"Multiplayer Plugins","parent":"Useful Info","content":"Netcode plugins are a powerful way to handle asymmetrical multiplayer plugins. It can allow clients to control the match, when normally only the host can. This is much better described in this video by CinderBlock\nhttps://youtu.be/jyFuN8k2uIs\u0026nbsp;\nIf you want to make your own netcode plugin, there\u0026rsquo;s a template for it just like normal plugins. It does all the setup shown in the above video automatically. Follow the README to install it\nhttps://github.com/ubelhj/BakkesmodNetcodePluginTemplate\u0026nbsp;\n"},{"id":16,"href":"/useful_info/other_languages/","title":"Other Languages","parent":"Useful Info","content":"There\u0026rsquo;s a couple super useful libraries that let you write plugins in other programming languages. We can\u0026rsquo;t really guarantee any tutorials in this server as we don\u0026rsquo;t have anyone with much experience in them. If you use them feel free to add help and make a pull request. You\u0026rsquo;re still welcome to ask for help with them in the discord\u0026nbsp;, but most people here use the standard C++ library and it may be hard to get specific help\nPython by Stanbroek    https://github.com/Stanbroek/BakkesModSDK-Python\u0026nbsp;\nRust by Arator    https://docs.rs/bakkesmod/0.2.1/bakkesmod/\u0026nbsp;\n"},{"id":17,"href":"/code_snippets/plugin_exclusive_logging/","title":"Plugin Exclusive Logging","parent":"Code Snippets","content":"Want to see the console logging from just your plugin? Open a new PowerShell window and use this command (It may require git for windows https://gitforwindows.org/\u0026nbsp;)\nGet-Content (-join($env:APPDATA, \u0026quot;\\bakkesmod\\bakkesmod\\bakkesmod.log\u0026quot;)) -wait -tail 1 | select-string -pattern \u0026quot;PLUGIN_NAME\u0026quot; "},{"id":18,"href":"/code_snippets/plugin_types/","title":"Plugin Types","parent":"Code Snippets","content":"All Plugin Types\nPLUGINTYPE_FREEPLAY = 0x01, // Does nothing  PLUGINTYPE_CUSTOM_TRAINING = 0x02, // see above  PLUGINTYPE_SPECTATOR = 0x04, // see above  PLUGINTYPE_BOTAI = 0x08, // see above  PLUGINTYPE_REPLAY = 0x10, // see above  PLUGINTYPE_THREADED = 0x20, // OnLoad is called in it\u0026#39;s own thread  PLUGINTYPE_THREADEDUNLOAD = 0x40 // Unload is called in it\u0026#39;s own thread "},{"id":19,"href":"/useful_info/submitting_to_bakkesplugins/","title":"Submitting to Bakkesplugins","parent":"Useful Info","content":"You\u0026rsquo;ve looked through the docs in desperation, angrily screamed at your computer, crashed a couple times, but it\u0026rsquo;s all worth it! You have made a super cool plugin that you want to share! Nice job!\nPlugins are officially hosted at https://bakkesplugins.com/\u0026nbsp;. Go there and sign up for an account. Please make the username similar to a discord or github you can be contacted at.\nOnce you\u0026rsquo;re logged in, hover over your name in the top right, hit Account, and then hit Add New Plugin\nYou\u0026rsquo;ll come to a new page asking for details. Give your plugin a title, a one-sentence description, and a longer description. Add any relevant tags too. You can also add a plugin homepage, which will be included as a link from the plugin page. This is a great place to link to the plugin\u0026rsquo;s source code on github, gitlab, or other version control host!\nAlso choose if it\u0026rsquo;s visible and publically listed. If not visible, nobody but you can see the plugin. If not listed your plugin will be accessible through the URL directly but not searchable. It is still easy to find a not listed plugin though, so only make a plugin visible if you\u0026rsquo;re comfortable with it being public\nNext upload a .png banner for the plugin. It should be below 50 MB? and wider than it is tall. 16 x 9 is a reasonable ratio.\nFinally is the plugin .zip. Make a .zip file including all of your source files and nothing else. You should include the .sln, the .vcxproj, any .cpp, .h, or .hpp files, and any other data files like .set or images to be included.\nIMAGE HERE OF TEMPLATE WITH SLN IN FOLDER\nIMAGE HERE OF TEMPLATE WITH SLN OUTSIDE FOLDER\nOnce you have everything just hit submit! All plugins are manually reviewed and built by volunteer moderators. It may take a couple days to a couple weeks depending on moderator availability. Please be respectful of the time it may take. Please use the plugin template\u0026nbsp; to make building to .dll smooth and easy for the moderators.\nIf your plugin includes any .dll files from outside sources or has weird build steps, please make it clear through a README or by asking in the discord. We will do our best to accomodate special exceptions if the plugin clearly needs it and moderators are capable of getting files from a safe source. For example Nvidia Highlights requires a pre-built .dll from Nvidia themselves, as it was easily accessible we were able to package that in a plugin download. If it\u0026rsquo;s unreasonably difficult to obtain outside source files or build the plugin, it will be denied\nBakkesplugins retains the right to deny or remove any plugin. A plugin will not be approved if it can be considered malicious, downloads and/or runs potentally dangerous files, breaks the Rocket League Code of Conduct\u0026rsquo;s rules for mods, or is otherwise not allowed by Psyonix\n"},{"id":20,"href":"/tags/","title":"Tags","parent":"Welcome to the BakkesMod Programming Wiki!","content":""},{"id":21,"href":"/code_snippets/toasts/","title":"Toasts","parent":"Code Snippets","content":"Toasts are cool little popups that show on the top right of your game\nThese are useful for quick notifications that you want to disappear quickly\nFirst you need to enable them in f2 - Misc - Enable notifications\nWatch out though! Every user also has to enable this, so make sure your plugin page or interface is quite clear that this is necessary\nNow to the code\nMake a toast pop up with GameWrapper.Toast()\u0026nbsp;\nThere are 7 parameters. The first two are required. They are\n The title, which is the word on top The text, which is the smaller text below The texture name which I\u0026rsquo;ll explain in the next paragraph The time to show the toast, which defaults to 3.5 seconds The ToastType, which chooses the color and defaults to black The width in pixels. The toast automatically resizes to fit your text, so don\u0026rsquo;t worry about these too much The height in pixels  If you want to have a custom image, load it in your onLoad() using GameWrapper.LoadToastTexture(). Provide the function with a name for your toast, and the path to the image. Most likely you\u0026rsquo;ll want it to be in the data folder.\nToasts can be one of 4 colors based on the ToastType\nI\u0026rsquo;ve made an example using CoolPlugin. I put this code in the onLoad() in CoolPlugin.cpp and cool.png in the bakkesmod/data folder\ngameWrapper-\u0026gt;LoadToastTexture(\u0026#34;cool\u0026#34;, gameWrapper-\u0026gt;GetDataFolder() / \u0026#34;cool.png\u0026#34;); cvarManager-\u0026gt;registerNotifier(\u0026#34;cool_toast\u0026#34;, [this](std::vector\u0026lt;std::string\u0026gt; args) { gameWrapper-\u0026gt;Toast(\u0026#34;Whoa you\u0026#39;re cool\u0026#34;, \u0026#34;Super cool\u0026#34;, \u0026#34;cool\u0026#34;, 5.0, ToastType_Warning); }, \u0026#34;\u0026#34;, PERMISSION_ALL); The result when I call cool_toast from the f6 console\nFor perspective, it\u0026rsquo;s quite small but still legible\nFull code here https://github.com/ubelhj/BakkesModStarterPlugin/tree/toasts\u0026nbsp;\n"},{"id":22,"href":"/useful_info/troubleshooting_bakkesmod/","title":"Troubleshooting Bakkesmod","parent":"Useful Info","content":"Made it here because your BakkesMod isn\u0026rsquo;t working? No worries, check this other wiki here\nhttps://bakkesmod.fandom.com/wiki/Troubleshooting\u0026nbsp;\n"},{"id":23,"href":"/useful_info/useful_links/","title":"Useful Links","parent":"Useful Info","content":"Here\u0026rsquo;s some links that we couldn\u0026rsquo;t find a good place for\nCreating a .set file https://bakkesmod.fandom.com/wiki/Plugin_settings_files\u0026nbsp;\nImGui demo https://pthom.github.io/imgui_manual_online/manual/imgui_manual.html\u0026nbsp;\nImGui builder program https://github.com/Code-Building/ImGuiBuilder\u0026nbsp;\nUseful game values (map size, boost locations, etc.) https://github.com/RLBot/RLBot/wiki/Useful-Game-Values\u0026nbsp;\nUDK site for canvas. The BM CanvasWrapper has some of these features https://docs.unrealengine.com/udk/Three/CanvasTechnicalGuide.html\u0026nbsp;\nCanvasWrapper library for improved tools https://github.com/CinderBlocc/RenderingTools\u0026nbsp;\n"},{"id":24,"href":"/code_snippets/using_http_wrapper/","title":"Using HttpWrapper","parent":"Code Snippets","content":"HttpWrapper    Sending a simple http request with a string body    CurlRequest req; req.url = \u0026#34;https://httpbin.org/anything\u0026#34;; req.body = \u0026#34;testing with body\u0026#34;; LOG(\u0026#34;sending body request\u0026#34;); HttpWrapper::SendCurlRequest(req, [this](int code, std::string result) { LOG(\u0026#34;Body result{}\u0026#34;, result); }); Perform an HTTP/S JSON request    CurlRequest req; req.url = \u0026#34;https://httpbin.org/anything\u0026#34;; req.body = R\u0026#34;T({ \u0026#34;userId\u0026#34;: 1, \u0026#34;id\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;delectus aut autem\u0026#34;, \u0026#34;completed\u0026#34;: false })T\u0026#34;; HttpWrapper::SendCurlJsonRequest(req, [this](int code, std::string result) { LOG(\u0026#34;Json result{}\u0026#34;, result); }); Sending a file over HTTP/S    { CurlRequest req; req.url = \u0026#34;https://httpbin.org/anything\u0026#34;; req.body = \u0026#34;testing body with file output\u0026#34;; LOG(\u0026#34;sending file output body request\u0026#34;); HttpWrapper::SendCurlRequest(req, L\u0026#34;file_output_test.txt\u0026#34;, [this](int code, std::wstring result) { LOG(\u0026#34;sending file output body request: returned\u0026#34;); }); Downloading a file with download progress callbacks and reading the raw downloaded data    CurlRequest req; req.url = \u0026#34;url\u0026#34;; req.progress_function = [](double file_size, double downloaded, ...) { if (file_size != 0) LOG(\u0026#34;Download progress {:.2f}%\u0026#34;, downloaded / file_size * 100); }; HttpWrapper::SendCurlRequest(req, [this](int code, char* data, size_t size) { std::ofstream out_file {\u0026#34;test_image_raw.jpeg\u0026#34;, std::ios_base::binary}; if (out_file) out_file.write(data, size); }); Downloading a file to the filesystem    CurlRequest req; req.url = \u0026#34;url\u0026#34;; LOG(\u0026#34;sending raw output image download request\u0026#34;); HttpWrapper::SendCurlRequest(req, L\u0026#34;test_image.jpeg\u0026#34;, [this](int code, std::wstring out_path) { LOG(\u0026#34;file image download code: {}\u0026#34;, code); }); "},{"id":25,"href":"/","title":"Welcome to the BakkesMod Programming Wiki!","parent":"","content":" Get Started with Plugins   Important Links:  Download BakkesMod\u0026nbsp;\nFind and Submit Plugins\u0026nbsp;\nBM Programming Discord\u0026nbsp;\n"}]